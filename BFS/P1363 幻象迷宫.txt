（喵星人LHX和WD同心协力击退了汪星人的入侵，不幸的是，汪星人撤退之前给它们制造了一片幻象迷宫。）

WD：呜呜，肿么办啊……

LHX：momo...我们一定能走出去的！

WD：嗯，+U+U！

描述 Description

幻象迷宫可以认为是无限大的，不过它由若干个N*M的矩阵重复组成。矩阵中有的地方是道路，用'.'表示；有的地方是墙，用'#'表示。LHX和WD所在的位置用'S'表示。也就是对于迷宫中的一个点(x,y)，如果(x mod n,y mod m)是'.'或者'S'，那么这个地方是道路；如果(x mod n,y mod m)是'#'，那么这个地方是墙。LHX和WD可以向上下左右四个方向移动，当然不能移动到墙上。

请你告诉LHX和WD，它们能否走出幻象迷宫（如果它们能走到距离起点无限远处，就认为能走出去）。如果不能的话，LHX就只好启动城堡的毁灭程序了……当然不到万不得已，他不想这么做。。。

输入格式
输入包含多组数据，以EOF结尾。

每组数据的第一行是两个整数N、M。

接下来是一个N*M的字符矩阵，表示迷宫里(0,0)到(n-1,m-1)这个矩阵单元。

输出格式
对于每组数据，输出一个字符串，Yes或者No。

输入输出样例
输入 #1 复制
5 4
##.#
##S#
#..#
#.##
#..#
5 4
##.#
##S#
#..#
..#.
#.##
输出 #1 复制
Yes
No

说明/提示
对于30%的数据，N,M<=20

对于50%的数据，N.M<=100.

对于100%的数据，N,M<=1500，每个测试点不超过10组数据.

思路：以为是一条线的，，，BFS直接上去就不知道为什么错了
更好的阅读体验点这里：博客传送门

搜索时判断能否重复到达某个点，当然迷宫的四个边界是分别相通的。

一开始想的是：

如果从上（下）边界的某个点能到达同一列下（上）边界的某个点，或者是从左（右）边界的某个点能够到达同一行右（左）边界的某个点，则可以走无限远

但这样的数据就会判断错误：

3 5
S.#..
#####
#...# 
并不能直接从上面到达下面但也是可以到达的，而且枚举边界上的点再搜索会超时

然后想了一个比较正确（但还是不正确）的方法：

把读入的一个迷宫变成九个迷宫，判断从起点(x,\ y)(x, y)能否走到(x + n,\ y)(x+n, y)或(x - n,\ y)(x?n, y)或(x,\ y + m)(x, y+m)或(x,\ y - m)(x, y?m).

但这么做如果要走不止一个迷宫才能回到起点就GGGG了

比如这组数据：

6 20
#.##.##.##.##.##.##.
#.##.##.##.##.##.##.
#.##.##.##.##.##.##.
S.#..#..#..#..#..#..
##..#..#..#..#..#..#
#..#..#..#..#..#..##
愉快地从下面跑到上面再跑到下面再...

显然这种情况把1 * 11?1迷宫拓展成3 * 33?3是不可取的，而如果拓展成9 * 99?9（或81 * 8181?81）那一定是会爆内存的。

下面是正解：
所以不能拓展迷宫而对坐标取模就好了.

如果走到过某个点现在又走到了这个点，那显然是可以走无限远的。

现在出现了一些（堆）问题：

如何判断是否走到过这个点呢？

有一个比较巧妙的方法：

记录取模的横纵坐标x,\ yx, y时，同时记录没有取模的坐标lx,\ lylx, ly
当第一次走这个迷宫的时候，x,\ yx, y和lx,\ lylx, ly肯定是分别相等的

所以只要走到的一个点的x,\ yx, y和lx,\ lylx, ly不相等（x≠lx\ ||\ y≠lyx≠lx OO y≠ly），那这个点一定是被走了第二遍.

上代码：
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;

const int MAXN = 1500 + 1;
const int dx[4] = {1, -1, 0, 0};
const int dy[4] = {0, 0, 1, -1};

int n, m;
int st_x, st_y;
int vis[MAXN][MAXN][3];
bool fl, a[MAXN][MAXN];
char ch;

void dfs(int x, int y, int lx, int ly) {
    if(fl) return;
    if(vis[x][y][0] && (vis[x][y][1]!=lx || vis[x][y][2]!=ly)) {
        fl = 1;
        return;
    }
    vis[x][y][1] = lx, vis[x][y][2] = ly, vis[x][y][0] = 1;
    for(int i=0; i<4; ++i) {
        int xx = (x + dx[i] + n) % n, yy = (y + dy[i] + m) % m;
        int lxx = lx + dx[i], lyy = ly + dy[i];
        if(!a[xx][yy]) {
            if(vis[xx][yy][1]!=lxx || vis[xx][yy][2]!=lyy || !vis[xx][yy][0])
                dfs(xx, yy, lxx, lyy);
        }
    }
}
int main() {
    ios::sync_with_stdio(false);
    while(cin >> n >> m) {
        fl = 0;
        memset(a, 0, sizeof(a));
        memset(vis, 0, sizeof(vis));
        for(int i=0; i<n; ++i)
            for(int j=0; j<m; ++j) {
                cin >> ch;
                if(ch == '#') a[i][j] = 1;
                if(ch == 'S') st_x = i, st_y = j;
            }
        dfs(st_x, st_y, st_x, st_y);
        if(fl) puts("Yes");
        else puts("No");
    }
}