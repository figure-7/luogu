提高+/省选-

“低价购买”这条建议是在奶牛股票市场取得成功的一半规则。要想被认为是伟大的投资者，你必须遵循以下的问题建议:“低价购买；再低价购买”。每次你购买一支股票,你必须用低于你上次购买它的价格购买它。买的次数越多越好!你的目标是在遵循以上建议的前提下，求你最多能购买股票的次数。你将被给出一段时间内一支股票每天的出售价(2^{16}2 
16
 范围内的正整数)，你可以选择在哪些天购买这支股票。每次购买都必须遵循“低价购买；再低价购买”的原则。写一个程序计算最大购买次数。

这里是某支股票的价格清单：

日期 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8, 9 ,10 ,11, 121,2,3,4,5,6,7,8,9,10,11,12

价格 68 ,69 ,54, 64,68 ,64 ,70 ,67 ,78 ,62, 98, 8768,69,54,64,68,64,70,67,78,62,98,87

最优秀的投资者可以购买最多44次股票，可行方案中的一种是：

日期 2 , 5 , 6 ,102,5,6,10

价格 69, 68 ,64 ,6269,68,64,62

输入格式
第1行: N(1 \le N \le 5000)N(1≤N≤5000)，股票发行天数

第2行: NN个数，是每天的股票价格。

输出格式
两个数:
最大购买次数和拥有最大购买次数的方案数( \le 2^{31}≤2 
31
 )当二种方案“看起来一样”时（就是说它们构成的价格队列一样的时候）,这22种方案被认为是相同的。

输入输出样例
输入 #1 复制
12
68 69 54 64 68 64 70 67 78 62 98 87
输出 #1 复制
4 2

思路：
这不是一道简单的求最长下降子序列的问题。

――因为这个题要输出不同种的方案数
题目要求是“它们构成的价格队列不一样”，那么我准备拿一个数组存下这个最长下降子序列，但是这不现实，检查是否匹配是在最坏的情况下可能达到Θ(N^3)Θ(N 
3
 )。

于是有了现在的解法，让我来简单证明说明一下

在dp过程中，f数组存的是最长下降子序列的长度，f数组的下标i是以i结尾的意思，所以最长下降子序列（除了最后一位外）的数据已经丢失，
因此不能在方案数相加时再判断是否能加。

我们从头来看，

如果一个数列的第一个数与另一个数列的第一个数相同，那么现在可以判断它们相等，即可以把其中一个删掉（在代码中的处理是t[i]=0）。
当不同的数接在它的后面时，又可以将它们判断为两个数列，这是不互相影响的。
因为两个数列都可以由这个相等的数列转移而来
如果一个数列的第一个数与另一个数列的第一个数不同，那么它们不等，且无论后面添加什么，都不相等，即不删去，则按照普通的判断继续做。
由上面的两点，我们已经把重复的删掉，这样可以防止重复计数。

tiptip：本题如果出现在考试中，请不要冒险定义int，因为maxint是2^{31}-12 
31
 ?1，会爆int，这个题暂不做深究

上代码：
#include<cstdio>
#include<cstring>
int max(int x,int y){return x>y?x:y;}
int a[5001],f[5001],t[5001];
//a[i]存的是第i天股票的价格
//f[i]存的是第i天最长下降子序列的长度
//t[i]存的是以i结尾的最长下降子序列的种类（方案）
int main()
{
    memset(f,0,sizeof(f));//初始化长度
    memset(t,0,sizeof(t));//初始化方案
    int n,maxx=0;
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        scanf("%d",&a[i]);
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<i;j++)
            if(a[i]<a[j])//延长已经存在的最长下降子序列
                f[i]=max(f[i],f[j]+1);
        if(f[i]==0)
            f[i]++;//如果当前的数是目前为止最大的，则最长下降子序列是自己
        if(f[i]>maxx)
            maxx=f[i];//在f数组更新完毕后，存下最长下降子序列的长度
        for(int j=1;j<i;j++)
            if(f[i]==f[j]&&a[i]==a[j])
                t[j]=0;//如果与前面的数列相同，则舍去前面的数列，防止重复计数
            else if(f[i]==f[j]+1&&a[i]<a[j])
                t[i]+=t[j];//如果可以接上前面的数列，则继承其方案数
        if(!t[i])//如果当前的数是目前为止最大的，则是初始方案
            t[i]=1;
    }
    int sum=0;//sum计数，用于存最长下降子序列（方案）的个数
    for(int i=1;i<=n;i++)
        if(f[i]==maxx)
            sum+=t[i];
    printf("%d %d",maxx,sum);
    return 0;
}