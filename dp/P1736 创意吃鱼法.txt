提高+/省选-

回到家中的猫猫把三桶鱼全部转移到了她那长方形大池子中，然后开始思考：到底要以何种方法吃鱼呢（猫猫就是这么可爱，吃鱼也要想好吃法 ^_*）。她发现，把大池子视为01矩阵（0表示对应位置无鱼，1表示对应位置有鱼）有助于决定吃鱼策略。

在代表池子的01矩阵中，有很多的正方形子矩阵，如果某个正方形子矩阵的某条对角线上都有鱼，且此正方形子矩阵的其他地方无鱼，猫猫就可以从这个正方形子矩阵“对角线的一端”下口，只一吸，就能把对角线上的那一队鲜鱼吸入口中。

猫猫是个贪婪的家伙，所以她想一口吃掉尽量多的鱼。请你帮猫猫计算一下，她一口下去，最多可以吃掉多少条鱼？

输入格式
有多组输入数据，每组数据：

第一行有两个整数n和m（n,m≥1），描述池塘规模。接下来的n行，每行有m个数字（非“0”即“1”）。每两个数字之间用空格隔开。

对于30%的数据，有n,m≤100

对于60%的数据，有n,m≤1000

对于100%的数据，有n,m≤2500

输出格式
只有一个整数――猫猫一口下去可以吃掉的鱼的数量，占一行，行末有回车。

输入输出样例
输入 #1 复制
4 6
0 1 0 1 0 0
0 0 1 0 1 0
1 1 0 0 0 1
0 1 1 0 1 0
输出 #1 复制
3
说明/提示
右上角的

1 0 0
0 1 0
0 0 1

思路：dp+预处理

这道题其实和P1387 最大正方形很像，只不过多了一个预处理罢了

s1[i][j]表示（i，j）最多向左（或右）延伸多少个格子，使这些格子中的数都是0（不包括（i，j））

s2[i][j]表示（i，j）最多向上延伸多少个格子，使这些格子中的数都是0（不包括（i，j））

f[i][j]表以（i，j）为右下（左下）角的最大对角线长度

方程：f[i][j]=min(f[i-1][j-1],min(s1[i][j-1],s2[i-1][j]))+1;

不懂可以根据这个例子想想

1 0 0 0 1 0 0 0 1 dp两遍，分别对应两条对角线

最后附上精简的代码

#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
#include<string>
#include<map>
typedef long long ll;
using namespace std;
int n,m,ans;
int a[2509][2509],f[2509][2509],s1[2509][2509],s2[2509][2509];//s1为横向，s2为纵向 
int main()
{
    cin>>n>>m;
    //第一遍左上――右下 
    for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++)
    {
        scanf("%d",&a[i][j]);
        if(!a[i][j])
        {
            s1[i][j]=s1[i][j-1]+1;
            s2[i][j]=s2[i-1][j]+1;
        }
        if(a[i][j])
        f[i][j]=min(f[i-1][j-1],min(s1[i][j-1],s2[i-1][j]))+1;
        ans=max(ans,f[i][j]);
    }
    //第二遍右上――左下 
    memset(f,0,sizeof(f)); 
    memset(s1,0,sizeof(s1));//数组置0 
    memset(s2,0,sizeof(s2)); 
    for(int i=1;i<=n;i++)
    for(int j=m;j>=1;j--)
    {
        if(!a[i][j])
        {
            s1[i][j]=s1[i][j+1]+1;
            s2[i][j]=s2[i-1][j]+1;
        }
        if(a[i][j])
        f[i][j]=min(f[i-1][j+1],min(s1[i][j+1],s2[i-1][j]))+1;
        ans=max(ans,f[i][j]);
    }
    cout<<ans<<endl;
    return 0;
}